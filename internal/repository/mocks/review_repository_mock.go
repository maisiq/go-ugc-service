// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/maisiq/go-ugc-service/internal/repository.ReviewRepository -o review_repository_mock.go -n ReviewRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	mm_repository "github.com/maisiq/go-ugc-service/internal/repository"
)

// ReviewRepositoryMock implements mm_repository.ReviewRepository
type ReviewRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateReview          func(ctx context.Context, review mm_repository.Review) (err error)
	funcCreateReviewOrigin    string
	inspectFuncCreateReview   func(ctx context.Context, review mm_repository.Review)
	afterCreateReviewCounter  uint64
	beforeCreateReviewCounter uint64
	CreateReviewMock          mReviewRepositoryMockCreateReview

	funcGetReviews          func(ctx context.Context, ID string) (ra1 []mm_repository.Review, err error)
	funcGetReviewsOrigin    string
	inspectFuncGetReviews   func(ctx context.Context, ID string)
	afterGetReviewsCounter  uint64
	beforeGetReviewsCounter uint64
	GetReviewsMock          mReviewRepositoryMockGetReviews

	funcUpdateReview          func(ctx context.Context, review mm_repository.Review) (err error)
	funcUpdateReviewOrigin    string
	inspectFuncUpdateReview   func(ctx context.Context, review mm_repository.Review)
	afterUpdateReviewCounter  uint64
	beforeUpdateReviewCounter uint64
	UpdateReviewMock          mReviewRepositoryMockUpdateReview
}

// NewReviewRepositoryMock returns a mock for mm_repository.ReviewRepository
func NewReviewRepositoryMock(t minimock.Tester) *ReviewRepositoryMock {
	m := &ReviewRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateReviewMock = mReviewRepositoryMockCreateReview{mock: m}
	m.CreateReviewMock.callArgs = []*ReviewRepositoryMockCreateReviewParams{}

	m.GetReviewsMock = mReviewRepositoryMockGetReviews{mock: m}
	m.GetReviewsMock.callArgs = []*ReviewRepositoryMockGetReviewsParams{}

	m.UpdateReviewMock = mReviewRepositoryMockUpdateReview{mock: m}
	m.UpdateReviewMock.callArgs = []*ReviewRepositoryMockUpdateReviewParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mReviewRepositoryMockCreateReview struct {
	optional           bool
	mock               *ReviewRepositoryMock
	defaultExpectation *ReviewRepositoryMockCreateReviewExpectation
	expectations       []*ReviewRepositoryMockCreateReviewExpectation

	callArgs []*ReviewRepositoryMockCreateReviewParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReviewRepositoryMockCreateReviewExpectation specifies expectation struct of the ReviewRepository.CreateReview
type ReviewRepositoryMockCreateReviewExpectation struct {
	mock               *ReviewRepositoryMock
	params             *ReviewRepositoryMockCreateReviewParams
	paramPtrs          *ReviewRepositoryMockCreateReviewParamPtrs
	expectationOrigins ReviewRepositoryMockCreateReviewExpectationOrigins
	results            *ReviewRepositoryMockCreateReviewResults
	returnOrigin       string
	Counter            uint64
}

// ReviewRepositoryMockCreateReviewParams contains parameters of the ReviewRepository.CreateReview
type ReviewRepositoryMockCreateReviewParams struct {
	ctx    context.Context
	review mm_repository.Review
}

// ReviewRepositoryMockCreateReviewParamPtrs contains pointers to parameters of the ReviewRepository.CreateReview
type ReviewRepositoryMockCreateReviewParamPtrs struct {
	ctx    *context.Context
	review *mm_repository.Review
}

// ReviewRepositoryMockCreateReviewResults contains results of the ReviewRepository.CreateReview
type ReviewRepositoryMockCreateReviewResults struct {
	err error
}

// ReviewRepositoryMockCreateReviewOrigins contains origins of expectations of the ReviewRepository.CreateReview
type ReviewRepositoryMockCreateReviewExpectationOrigins struct {
	origin       string
	originCtx    string
	originReview string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateReview *mReviewRepositoryMockCreateReview) Optional() *mReviewRepositoryMockCreateReview {
	mmCreateReview.optional = true
	return mmCreateReview
}

// Expect sets up expected params for ReviewRepository.CreateReview
func (mmCreateReview *mReviewRepositoryMockCreateReview) Expect(ctx context.Context, review mm_repository.Review) *mReviewRepositoryMockCreateReview {
	if mmCreateReview.mock.funcCreateReview != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by Set")
	}

	if mmCreateReview.defaultExpectation == nil {
		mmCreateReview.defaultExpectation = &ReviewRepositoryMockCreateReviewExpectation{}
	}

	if mmCreateReview.defaultExpectation.paramPtrs != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by ExpectParams functions")
	}

	mmCreateReview.defaultExpectation.params = &ReviewRepositoryMockCreateReviewParams{ctx, review}
	mmCreateReview.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateReview.expectations {
		if minimock.Equal(e.params, mmCreateReview.defaultExpectation.params) {
			mmCreateReview.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReview.defaultExpectation.params)
		}
	}

	return mmCreateReview
}

// ExpectCtxParam1 sets up expected param ctx for ReviewRepository.CreateReview
func (mmCreateReview *mReviewRepositoryMockCreateReview) ExpectCtxParam1(ctx context.Context) *mReviewRepositoryMockCreateReview {
	if mmCreateReview.mock.funcCreateReview != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by Set")
	}

	if mmCreateReview.defaultExpectation == nil {
		mmCreateReview.defaultExpectation = &ReviewRepositoryMockCreateReviewExpectation{}
	}

	if mmCreateReview.defaultExpectation.params != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by Expect")
	}

	if mmCreateReview.defaultExpectation.paramPtrs == nil {
		mmCreateReview.defaultExpectation.paramPtrs = &ReviewRepositoryMockCreateReviewParamPtrs{}
	}
	mmCreateReview.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateReview.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateReview
}

// ExpectReviewParam2 sets up expected param review for ReviewRepository.CreateReview
func (mmCreateReview *mReviewRepositoryMockCreateReview) ExpectReviewParam2(review mm_repository.Review) *mReviewRepositoryMockCreateReview {
	if mmCreateReview.mock.funcCreateReview != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by Set")
	}

	if mmCreateReview.defaultExpectation == nil {
		mmCreateReview.defaultExpectation = &ReviewRepositoryMockCreateReviewExpectation{}
	}

	if mmCreateReview.defaultExpectation.params != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by Expect")
	}

	if mmCreateReview.defaultExpectation.paramPtrs == nil {
		mmCreateReview.defaultExpectation.paramPtrs = &ReviewRepositoryMockCreateReviewParamPtrs{}
	}
	mmCreateReview.defaultExpectation.paramPtrs.review = &review
	mmCreateReview.defaultExpectation.expectationOrigins.originReview = minimock.CallerInfo(1)

	return mmCreateReview
}

// Inspect accepts an inspector function that has same arguments as the ReviewRepository.CreateReview
func (mmCreateReview *mReviewRepositoryMockCreateReview) Inspect(f func(ctx context.Context, review mm_repository.Review)) *mReviewRepositoryMockCreateReview {
	if mmCreateReview.mock.inspectFuncCreateReview != nil {
		mmCreateReview.mock.t.Fatalf("Inspect function is already set for ReviewRepositoryMock.CreateReview")
	}

	mmCreateReview.mock.inspectFuncCreateReview = f

	return mmCreateReview
}

// Return sets up results that will be returned by ReviewRepository.CreateReview
func (mmCreateReview *mReviewRepositoryMockCreateReview) Return(err error) *ReviewRepositoryMock {
	if mmCreateReview.mock.funcCreateReview != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by Set")
	}

	if mmCreateReview.defaultExpectation == nil {
		mmCreateReview.defaultExpectation = &ReviewRepositoryMockCreateReviewExpectation{mock: mmCreateReview.mock}
	}
	mmCreateReview.defaultExpectation.results = &ReviewRepositoryMockCreateReviewResults{err}
	mmCreateReview.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateReview.mock
}

// Set uses given function f to mock the ReviewRepository.CreateReview method
func (mmCreateReview *mReviewRepositoryMockCreateReview) Set(f func(ctx context.Context, review mm_repository.Review) (err error)) *ReviewRepositoryMock {
	if mmCreateReview.defaultExpectation != nil {
		mmCreateReview.mock.t.Fatalf("Default expectation is already set for the ReviewRepository.CreateReview method")
	}

	if len(mmCreateReview.expectations) > 0 {
		mmCreateReview.mock.t.Fatalf("Some expectations are already set for the ReviewRepository.CreateReview method")
	}

	mmCreateReview.mock.funcCreateReview = f
	mmCreateReview.mock.funcCreateReviewOrigin = minimock.CallerInfo(1)
	return mmCreateReview.mock
}

// When sets expectation for the ReviewRepository.CreateReview which will trigger the result defined by the following
// Then helper
func (mmCreateReview *mReviewRepositoryMockCreateReview) When(ctx context.Context, review mm_repository.Review) *ReviewRepositoryMockCreateReviewExpectation {
	if mmCreateReview.mock.funcCreateReview != nil {
		mmCreateReview.mock.t.Fatalf("ReviewRepositoryMock.CreateReview mock is already set by Set")
	}

	expectation := &ReviewRepositoryMockCreateReviewExpectation{
		mock:               mmCreateReview.mock,
		params:             &ReviewRepositoryMockCreateReviewParams{ctx, review},
		expectationOrigins: ReviewRepositoryMockCreateReviewExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateReview.expectations = append(mmCreateReview.expectations, expectation)
	return expectation
}

// Then sets up ReviewRepository.CreateReview return parameters for the expectation previously defined by the When method
func (e *ReviewRepositoryMockCreateReviewExpectation) Then(err error) *ReviewRepositoryMock {
	e.results = &ReviewRepositoryMockCreateReviewResults{err}
	return e.mock
}

// Times sets number of times ReviewRepository.CreateReview should be invoked
func (mmCreateReview *mReviewRepositoryMockCreateReview) Times(n uint64) *mReviewRepositoryMockCreateReview {
	if n == 0 {
		mmCreateReview.mock.t.Fatalf("Times of ReviewRepositoryMock.CreateReview mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateReview.expectedInvocations, n)
	mmCreateReview.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateReview
}

func (mmCreateReview *mReviewRepositoryMockCreateReview) invocationsDone() bool {
	if len(mmCreateReview.expectations) == 0 && mmCreateReview.defaultExpectation == nil && mmCreateReview.mock.funcCreateReview == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateReview.mock.afterCreateReviewCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateReview.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateReview implements mm_repository.ReviewRepository
func (mmCreateReview *ReviewRepositoryMock) CreateReview(ctx context.Context, review mm_repository.Review) (err error) {
	mm_atomic.AddUint64(&mmCreateReview.beforeCreateReviewCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReview.afterCreateReviewCounter, 1)

	mmCreateReview.t.Helper()

	if mmCreateReview.inspectFuncCreateReview != nil {
		mmCreateReview.inspectFuncCreateReview(ctx, review)
	}

	mm_params := ReviewRepositoryMockCreateReviewParams{ctx, review}

	// Record call args
	mmCreateReview.CreateReviewMock.mutex.Lock()
	mmCreateReview.CreateReviewMock.callArgs = append(mmCreateReview.CreateReviewMock.callArgs, &mm_params)
	mmCreateReview.CreateReviewMock.mutex.Unlock()

	for _, e := range mmCreateReview.CreateReviewMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCreateReview.CreateReviewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReview.CreateReviewMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReview.CreateReviewMock.defaultExpectation.params
		mm_want_ptrs := mmCreateReview.CreateReviewMock.defaultExpectation.paramPtrs

		mm_got := ReviewRepositoryMockCreateReviewParams{ctx, review}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateReview.t.Errorf("ReviewRepositoryMock.CreateReview got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReview.CreateReviewMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.review != nil && !minimock.Equal(*mm_want_ptrs.review, mm_got.review) {
				mmCreateReview.t.Errorf("ReviewRepositoryMock.CreateReview got unexpected parameter review, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReview.CreateReviewMock.defaultExpectation.expectationOrigins.originReview, *mm_want_ptrs.review, mm_got.review, minimock.Diff(*mm_want_ptrs.review, mm_got.review))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReview.t.Errorf("ReviewRepositoryMock.CreateReview got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateReview.CreateReviewMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReview.CreateReviewMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReview.t.Fatal("No results are set for the ReviewRepositoryMock.CreateReview")
		}
		return (*mm_results).err
	}
	if mmCreateReview.funcCreateReview != nil {
		return mmCreateReview.funcCreateReview(ctx, review)
	}
	mmCreateReview.t.Fatalf("Unexpected call to ReviewRepositoryMock.CreateReview. %v %v", ctx, review)
	return
}

// CreateReviewAfterCounter returns a count of finished ReviewRepositoryMock.CreateReview invocations
func (mmCreateReview *ReviewRepositoryMock) CreateReviewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReview.afterCreateReviewCounter)
}

// CreateReviewBeforeCounter returns a count of ReviewRepositoryMock.CreateReview invocations
func (mmCreateReview *ReviewRepositoryMock) CreateReviewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReview.beforeCreateReviewCounter)
}

// Calls returns a list of arguments used in each call to ReviewRepositoryMock.CreateReview.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReview *mReviewRepositoryMockCreateReview) Calls() []*ReviewRepositoryMockCreateReviewParams {
	mmCreateReview.mutex.RLock()

	argCopy := make([]*ReviewRepositoryMockCreateReviewParams, len(mmCreateReview.callArgs))
	copy(argCopy, mmCreateReview.callArgs)

	mmCreateReview.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReviewDone returns true if the count of the CreateReview invocations corresponds
// the number of defined expectations
func (m *ReviewRepositoryMock) MinimockCreateReviewDone() bool {
	if m.CreateReviewMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateReviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateReviewMock.invocationsDone()
}

// MinimockCreateReviewInspect logs each unmet expectation
func (m *ReviewRepositoryMock) MinimockCreateReviewInspect() {
	for _, e := range m.CreateReviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReviewRepositoryMock.CreateReview at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateReviewCounter := mm_atomic.LoadUint64(&m.afterCreateReviewCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReviewMock.defaultExpectation != nil && afterCreateReviewCounter < 1 {
		if m.CreateReviewMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReviewRepositoryMock.CreateReview at\n%s", m.CreateReviewMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReviewRepositoryMock.CreateReview at\n%s with params: %#v", m.CreateReviewMock.defaultExpectation.expectationOrigins.origin, *m.CreateReviewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReview != nil && afterCreateReviewCounter < 1 {
		m.t.Errorf("Expected call to ReviewRepositoryMock.CreateReview at\n%s", m.funcCreateReviewOrigin)
	}

	if !m.CreateReviewMock.invocationsDone() && afterCreateReviewCounter > 0 {
		m.t.Errorf("Expected %d calls to ReviewRepositoryMock.CreateReview at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateReviewMock.expectedInvocations), m.CreateReviewMock.expectedInvocationsOrigin, afterCreateReviewCounter)
	}
}

type mReviewRepositoryMockGetReviews struct {
	optional           bool
	mock               *ReviewRepositoryMock
	defaultExpectation *ReviewRepositoryMockGetReviewsExpectation
	expectations       []*ReviewRepositoryMockGetReviewsExpectation

	callArgs []*ReviewRepositoryMockGetReviewsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReviewRepositoryMockGetReviewsExpectation specifies expectation struct of the ReviewRepository.GetReviews
type ReviewRepositoryMockGetReviewsExpectation struct {
	mock               *ReviewRepositoryMock
	params             *ReviewRepositoryMockGetReviewsParams
	paramPtrs          *ReviewRepositoryMockGetReviewsParamPtrs
	expectationOrigins ReviewRepositoryMockGetReviewsExpectationOrigins
	results            *ReviewRepositoryMockGetReviewsResults
	returnOrigin       string
	Counter            uint64
}

// ReviewRepositoryMockGetReviewsParams contains parameters of the ReviewRepository.GetReviews
type ReviewRepositoryMockGetReviewsParams struct {
	ctx context.Context
	ID  string
}

// ReviewRepositoryMockGetReviewsParamPtrs contains pointers to parameters of the ReviewRepository.GetReviews
type ReviewRepositoryMockGetReviewsParamPtrs struct {
	ctx *context.Context
	ID  *string
}

// ReviewRepositoryMockGetReviewsResults contains results of the ReviewRepository.GetReviews
type ReviewRepositoryMockGetReviewsResults struct {
	ra1 []mm_repository.Review
	err error
}

// ReviewRepositoryMockGetReviewsOrigins contains origins of expectations of the ReviewRepository.GetReviews
type ReviewRepositoryMockGetReviewsExpectationOrigins struct {
	origin    string
	originCtx string
	originID  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetReviews *mReviewRepositoryMockGetReviews) Optional() *mReviewRepositoryMockGetReviews {
	mmGetReviews.optional = true
	return mmGetReviews
}

// Expect sets up expected params for ReviewRepository.GetReviews
func (mmGetReviews *mReviewRepositoryMockGetReviews) Expect(ctx context.Context, ID string) *mReviewRepositoryMockGetReviews {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by Set")
	}

	if mmGetReviews.defaultExpectation == nil {
		mmGetReviews.defaultExpectation = &ReviewRepositoryMockGetReviewsExpectation{}
	}

	if mmGetReviews.defaultExpectation.paramPtrs != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by ExpectParams functions")
	}

	mmGetReviews.defaultExpectation.params = &ReviewRepositoryMockGetReviewsParams{ctx, ID}
	mmGetReviews.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetReviews.expectations {
		if minimock.Equal(e.params, mmGetReviews.defaultExpectation.params) {
			mmGetReviews.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetReviews.defaultExpectation.params)
		}
	}

	return mmGetReviews
}

// ExpectCtxParam1 sets up expected param ctx for ReviewRepository.GetReviews
func (mmGetReviews *mReviewRepositoryMockGetReviews) ExpectCtxParam1(ctx context.Context) *mReviewRepositoryMockGetReviews {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by Set")
	}

	if mmGetReviews.defaultExpectation == nil {
		mmGetReviews.defaultExpectation = &ReviewRepositoryMockGetReviewsExpectation{}
	}

	if mmGetReviews.defaultExpectation.params != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by Expect")
	}

	if mmGetReviews.defaultExpectation.paramPtrs == nil {
		mmGetReviews.defaultExpectation.paramPtrs = &ReviewRepositoryMockGetReviewsParamPtrs{}
	}
	mmGetReviews.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetReviews.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetReviews
}

// ExpectIDParam2 sets up expected param ID for ReviewRepository.GetReviews
func (mmGetReviews *mReviewRepositoryMockGetReviews) ExpectIDParam2(ID string) *mReviewRepositoryMockGetReviews {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by Set")
	}

	if mmGetReviews.defaultExpectation == nil {
		mmGetReviews.defaultExpectation = &ReviewRepositoryMockGetReviewsExpectation{}
	}

	if mmGetReviews.defaultExpectation.params != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by Expect")
	}

	if mmGetReviews.defaultExpectation.paramPtrs == nil {
		mmGetReviews.defaultExpectation.paramPtrs = &ReviewRepositoryMockGetReviewsParamPtrs{}
	}
	mmGetReviews.defaultExpectation.paramPtrs.ID = &ID
	mmGetReviews.defaultExpectation.expectationOrigins.originID = minimock.CallerInfo(1)

	return mmGetReviews
}

// Inspect accepts an inspector function that has same arguments as the ReviewRepository.GetReviews
func (mmGetReviews *mReviewRepositoryMockGetReviews) Inspect(f func(ctx context.Context, ID string)) *mReviewRepositoryMockGetReviews {
	if mmGetReviews.mock.inspectFuncGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("Inspect function is already set for ReviewRepositoryMock.GetReviews")
	}

	mmGetReviews.mock.inspectFuncGetReviews = f

	return mmGetReviews
}

// Return sets up results that will be returned by ReviewRepository.GetReviews
func (mmGetReviews *mReviewRepositoryMockGetReviews) Return(ra1 []mm_repository.Review, err error) *ReviewRepositoryMock {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by Set")
	}

	if mmGetReviews.defaultExpectation == nil {
		mmGetReviews.defaultExpectation = &ReviewRepositoryMockGetReviewsExpectation{mock: mmGetReviews.mock}
	}
	mmGetReviews.defaultExpectation.results = &ReviewRepositoryMockGetReviewsResults{ra1, err}
	mmGetReviews.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetReviews.mock
}

// Set uses given function f to mock the ReviewRepository.GetReviews method
func (mmGetReviews *mReviewRepositoryMockGetReviews) Set(f func(ctx context.Context, ID string) (ra1 []mm_repository.Review, err error)) *ReviewRepositoryMock {
	if mmGetReviews.defaultExpectation != nil {
		mmGetReviews.mock.t.Fatalf("Default expectation is already set for the ReviewRepository.GetReviews method")
	}

	if len(mmGetReviews.expectations) > 0 {
		mmGetReviews.mock.t.Fatalf("Some expectations are already set for the ReviewRepository.GetReviews method")
	}

	mmGetReviews.mock.funcGetReviews = f
	mmGetReviews.mock.funcGetReviewsOrigin = minimock.CallerInfo(1)
	return mmGetReviews.mock
}

// When sets expectation for the ReviewRepository.GetReviews which will trigger the result defined by the following
// Then helper
func (mmGetReviews *mReviewRepositoryMockGetReviews) When(ctx context.Context, ID string) *ReviewRepositoryMockGetReviewsExpectation {
	if mmGetReviews.mock.funcGetReviews != nil {
		mmGetReviews.mock.t.Fatalf("ReviewRepositoryMock.GetReviews mock is already set by Set")
	}

	expectation := &ReviewRepositoryMockGetReviewsExpectation{
		mock:               mmGetReviews.mock,
		params:             &ReviewRepositoryMockGetReviewsParams{ctx, ID},
		expectationOrigins: ReviewRepositoryMockGetReviewsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetReviews.expectations = append(mmGetReviews.expectations, expectation)
	return expectation
}

// Then sets up ReviewRepository.GetReviews return parameters for the expectation previously defined by the When method
func (e *ReviewRepositoryMockGetReviewsExpectation) Then(ra1 []mm_repository.Review, err error) *ReviewRepositoryMock {
	e.results = &ReviewRepositoryMockGetReviewsResults{ra1, err}
	return e.mock
}

// Times sets number of times ReviewRepository.GetReviews should be invoked
func (mmGetReviews *mReviewRepositoryMockGetReviews) Times(n uint64) *mReviewRepositoryMockGetReviews {
	if n == 0 {
		mmGetReviews.mock.t.Fatalf("Times of ReviewRepositoryMock.GetReviews mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetReviews.expectedInvocations, n)
	mmGetReviews.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetReviews
}

func (mmGetReviews *mReviewRepositoryMockGetReviews) invocationsDone() bool {
	if len(mmGetReviews.expectations) == 0 && mmGetReviews.defaultExpectation == nil && mmGetReviews.mock.funcGetReviews == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetReviews.mock.afterGetReviewsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetReviews.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetReviews implements mm_repository.ReviewRepository
func (mmGetReviews *ReviewRepositoryMock) GetReviews(ctx context.Context, ID string) (ra1 []mm_repository.Review, err error) {
	mm_atomic.AddUint64(&mmGetReviews.beforeGetReviewsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetReviews.afterGetReviewsCounter, 1)

	mmGetReviews.t.Helper()

	if mmGetReviews.inspectFuncGetReviews != nil {
		mmGetReviews.inspectFuncGetReviews(ctx, ID)
	}

	mm_params := ReviewRepositoryMockGetReviewsParams{ctx, ID}

	// Record call args
	mmGetReviews.GetReviewsMock.mutex.Lock()
	mmGetReviews.GetReviewsMock.callArgs = append(mmGetReviews.GetReviewsMock.callArgs, &mm_params)
	mmGetReviews.GetReviewsMock.mutex.Unlock()

	for _, e := range mmGetReviews.GetReviewsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ra1, e.results.err
		}
	}

	if mmGetReviews.GetReviewsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetReviews.GetReviewsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetReviews.GetReviewsMock.defaultExpectation.params
		mm_want_ptrs := mmGetReviews.GetReviewsMock.defaultExpectation.paramPtrs

		mm_got := ReviewRepositoryMockGetReviewsParams{ctx, ID}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetReviews.t.Errorf("ReviewRepositoryMock.GetReviews got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReviews.GetReviewsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.ID != nil && !minimock.Equal(*mm_want_ptrs.ID, mm_got.ID) {
				mmGetReviews.t.Errorf("ReviewRepositoryMock.GetReviews got unexpected parameter ID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetReviews.GetReviewsMock.defaultExpectation.expectationOrigins.originID, *mm_want_ptrs.ID, mm_got.ID, minimock.Diff(*mm_want_ptrs.ID, mm_got.ID))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetReviews.t.Errorf("ReviewRepositoryMock.GetReviews got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetReviews.GetReviewsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetReviews.GetReviewsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetReviews.t.Fatal("No results are set for the ReviewRepositoryMock.GetReviews")
		}
		return (*mm_results).ra1, (*mm_results).err
	}
	if mmGetReviews.funcGetReviews != nil {
		return mmGetReviews.funcGetReviews(ctx, ID)
	}
	mmGetReviews.t.Fatalf("Unexpected call to ReviewRepositoryMock.GetReviews. %v %v", ctx, ID)
	return
}

// GetReviewsAfterCounter returns a count of finished ReviewRepositoryMock.GetReviews invocations
func (mmGetReviews *ReviewRepositoryMock) GetReviewsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReviews.afterGetReviewsCounter)
}

// GetReviewsBeforeCounter returns a count of ReviewRepositoryMock.GetReviews invocations
func (mmGetReviews *ReviewRepositoryMock) GetReviewsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetReviews.beforeGetReviewsCounter)
}

// Calls returns a list of arguments used in each call to ReviewRepositoryMock.GetReviews.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetReviews *mReviewRepositoryMockGetReviews) Calls() []*ReviewRepositoryMockGetReviewsParams {
	mmGetReviews.mutex.RLock()

	argCopy := make([]*ReviewRepositoryMockGetReviewsParams, len(mmGetReviews.callArgs))
	copy(argCopy, mmGetReviews.callArgs)

	mmGetReviews.mutex.RUnlock()

	return argCopy
}

// MinimockGetReviewsDone returns true if the count of the GetReviews invocations corresponds
// the number of defined expectations
func (m *ReviewRepositoryMock) MinimockGetReviewsDone() bool {
	if m.GetReviewsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetReviewsMock.invocationsDone()
}

// MinimockGetReviewsInspect logs each unmet expectation
func (m *ReviewRepositoryMock) MinimockGetReviewsInspect() {
	for _, e := range m.GetReviewsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReviewRepositoryMock.GetReviews at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetReviewsCounter := mm_atomic.LoadUint64(&m.afterGetReviewsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetReviewsMock.defaultExpectation != nil && afterGetReviewsCounter < 1 {
		if m.GetReviewsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReviewRepositoryMock.GetReviews at\n%s", m.GetReviewsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReviewRepositoryMock.GetReviews at\n%s with params: %#v", m.GetReviewsMock.defaultExpectation.expectationOrigins.origin, *m.GetReviewsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetReviews != nil && afterGetReviewsCounter < 1 {
		m.t.Errorf("Expected call to ReviewRepositoryMock.GetReviews at\n%s", m.funcGetReviewsOrigin)
	}

	if !m.GetReviewsMock.invocationsDone() && afterGetReviewsCounter > 0 {
		m.t.Errorf("Expected %d calls to ReviewRepositoryMock.GetReviews at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetReviewsMock.expectedInvocations), m.GetReviewsMock.expectedInvocationsOrigin, afterGetReviewsCounter)
	}
}

type mReviewRepositoryMockUpdateReview struct {
	optional           bool
	mock               *ReviewRepositoryMock
	defaultExpectation *ReviewRepositoryMockUpdateReviewExpectation
	expectations       []*ReviewRepositoryMockUpdateReviewExpectation

	callArgs []*ReviewRepositoryMockUpdateReviewParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ReviewRepositoryMockUpdateReviewExpectation specifies expectation struct of the ReviewRepository.UpdateReview
type ReviewRepositoryMockUpdateReviewExpectation struct {
	mock               *ReviewRepositoryMock
	params             *ReviewRepositoryMockUpdateReviewParams
	paramPtrs          *ReviewRepositoryMockUpdateReviewParamPtrs
	expectationOrigins ReviewRepositoryMockUpdateReviewExpectationOrigins
	results            *ReviewRepositoryMockUpdateReviewResults
	returnOrigin       string
	Counter            uint64
}

// ReviewRepositoryMockUpdateReviewParams contains parameters of the ReviewRepository.UpdateReview
type ReviewRepositoryMockUpdateReviewParams struct {
	ctx    context.Context
	review mm_repository.Review
}

// ReviewRepositoryMockUpdateReviewParamPtrs contains pointers to parameters of the ReviewRepository.UpdateReview
type ReviewRepositoryMockUpdateReviewParamPtrs struct {
	ctx    *context.Context
	review *mm_repository.Review
}

// ReviewRepositoryMockUpdateReviewResults contains results of the ReviewRepository.UpdateReview
type ReviewRepositoryMockUpdateReviewResults struct {
	err error
}

// ReviewRepositoryMockUpdateReviewOrigins contains origins of expectations of the ReviewRepository.UpdateReview
type ReviewRepositoryMockUpdateReviewExpectationOrigins struct {
	origin       string
	originCtx    string
	originReview string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) Optional() *mReviewRepositoryMockUpdateReview {
	mmUpdateReview.optional = true
	return mmUpdateReview
}

// Expect sets up expected params for ReviewRepository.UpdateReview
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) Expect(ctx context.Context, review mm_repository.Review) *mReviewRepositoryMockUpdateReview {
	if mmUpdateReview.mock.funcUpdateReview != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by Set")
	}

	if mmUpdateReview.defaultExpectation == nil {
		mmUpdateReview.defaultExpectation = &ReviewRepositoryMockUpdateReviewExpectation{}
	}

	if mmUpdateReview.defaultExpectation.paramPtrs != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by ExpectParams functions")
	}

	mmUpdateReview.defaultExpectation.params = &ReviewRepositoryMockUpdateReviewParams{ctx, review}
	mmUpdateReview.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateReview.expectations {
		if minimock.Equal(e.params, mmUpdateReview.defaultExpectation.params) {
			mmUpdateReview.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReview.defaultExpectation.params)
		}
	}

	return mmUpdateReview
}

// ExpectCtxParam1 sets up expected param ctx for ReviewRepository.UpdateReview
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) ExpectCtxParam1(ctx context.Context) *mReviewRepositoryMockUpdateReview {
	if mmUpdateReview.mock.funcUpdateReview != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by Set")
	}

	if mmUpdateReview.defaultExpectation == nil {
		mmUpdateReview.defaultExpectation = &ReviewRepositoryMockUpdateReviewExpectation{}
	}

	if mmUpdateReview.defaultExpectation.params != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by Expect")
	}

	if mmUpdateReview.defaultExpectation.paramPtrs == nil {
		mmUpdateReview.defaultExpectation.paramPtrs = &ReviewRepositoryMockUpdateReviewParamPtrs{}
	}
	mmUpdateReview.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateReview.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateReview
}

// ExpectReviewParam2 sets up expected param review for ReviewRepository.UpdateReview
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) ExpectReviewParam2(review mm_repository.Review) *mReviewRepositoryMockUpdateReview {
	if mmUpdateReview.mock.funcUpdateReview != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by Set")
	}

	if mmUpdateReview.defaultExpectation == nil {
		mmUpdateReview.defaultExpectation = &ReviewRepositoryMockUpdateReviewExpectation{}
	}

	if mmUpdateReview.defaultExpectation.params != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by Expect")
	}

	if mmUpdateReview.defaultExpectation.paramPtrs == nil {
		mmUpdateReview.defaultExpectation.paramPtrs = &ReviewRepositoryMockUpdateReviewParamPtrs{}
	}
	mmUpdateReview.defaultExpectation.paramPtrs.review = &review
	mmUpdateReview.defaultExpectation.expectationOrigins.originReview = minimock.CallerInfo(1)

	return mmUpdateReview
}

// Inspect accepts an inspector function that has same arguments as the ReviewRepository.UpdateReview
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) Inspect(f func(ctx context.Context, review mm_repository.Review)) *mReviewRepositoryMockUpdateReview {
	if mmUpdateReview.mock.inspectFuncUpdateReview != nil {
		mmUpdateReview.mock.t.Fatalf("Inspect function is already set for ReviewRepositoryMock.UpdateReview")
	}

	mmUpdateReview.mock.inspectFuncUpdateReview = f

	return mmUpdateReview
}

// Return sets up results that will be returned by ReviewRepository.UpdateReview
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) Return(err error) *ReviewRepositoryMock {
	if mmUpdateReview.mock.funcUpdateReview != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by Set")
	}

	if mmUpdateReview.defaultExpectation == nil {
		mmUpdateReview.defaultExpectation = &ReviewRepositoryMockUpdateReviewExpectation{mock: mmUpdateReview.mock}
	}
	mmUpdateReview.defaultExpectation.results = &ReviewRepositoryMockUpdateReviewResults{err}
	mmUpdateReview.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateReview.mock
}

// Set uses given function f to mock the ReviewRepository.UpdateReview method
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) Set(f func(ctx context.Context, review mm_repository.Review) (err error)) *ReviewRepositoryMock {
	if mmUpdateReview.defaultExpectation != nil {
		mmUpdateReview.mock.t.Fatalf("Default expectation is already set for the ReviewRepository.UpdateReview method")
	}

	if len(mmUpdateReview.expectations) > 0 {
		mmUpdateReview.mock.t.Fatalf("Some expectations are already set for the ReviewRepository.UpdateReview method")
	}

	mmUpdateReview.mock.funcUpdateReview = f
	mmUpdateReview.mock.funcUpdateReviewOrigin = minimock.CallerInfo(1)
	return mmUpdateReview.mock
}

// When sets expectation for the ReviewRepository.UpdateReview which will trigger the result defined by the following
// Then helper
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) When(ctx context.Context, review mm_repository.Review) *ReviewRepositoryMockUpdateReviewExpectation {
	if mmUpdateReview.mock.funcUpdateReview != nil {
		mmUpdateReview.mock.t.Fatalf("ReviewRepositoryMock.UpdateReview mock is already set by Set")
	}

	expectation := &ReviewRepositoryMockUpdateReviewExpectation{
		mock:               mmUpdateReview.mock,
		params:             &ReviewRepositoryMockUpdateReviewParams{ctx, review},
		expectationOrigins: ReviewRepositoryMockUpdateReviewExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateReview.expectations = append(mmUpdateReview.expectations, expectation)
	return expectation
}

// Then sets up ReviewRepository.UpdateReview return parameters for the expectation previously defined by the When method
func (e *ReviewRepositoryMockUpdateReviewExpectation) Then(err error) *ReviewRepositoryMock {
	e.results = &ReviewRepositoryMockUpdateReviewResults{err}
	return e.mock
}

// Times sets number of times ReviewRepository.UpdateReview should be invoked
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) Times(n uint64) *mReviewRepositoryMockUpdateReview {
	if n == 0 {
		mmUpdateReview.mock.t.Fatalf("Times of ReviewRepositoryMock.UpdateReview mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReview.expectedInvocations, n)
	mmUpdateReview.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateReview
}

func (mmUpdateReview *mReviewRepositoryMockUpdateReview) invocationsDone() bool {
	if len(mmUpdateReview.expectations) == 0 && mmUpdateReview.defaultExpectation == nil && mmUpdateReview.mock.funcUpdateReview == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReview.mock.afterUpdateReviewCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReview.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReview implements mm_repository.ReviewRepository
func (mmUpdateReview *ReviewRepositoryMock) UpdateReview(ctx context.Context, review mm_repository.Review) (err error) {
	mm_atomic.AddUint64(&mmUpdateReview.beforeUpdateReviewCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReview.afterUpdateReviewCounter, 1)

	mmUpdateReview.t.Helper()

	if mmUpdateReview.inspectFuncUpdateReview != nil {
		mmUpdateReview.inspectFuncUpdateReview(ctx, review)
	}

	mm_params := ReviewRepositoryMockUpdateReviewParams{ctx, review}

	// Record call args
	mmUpdateReview.UpdateReviewMock.mutex.Lock()
	mmUpdateReview.UpdateReviewMock.callArgs = append(mmUpdateReview.UpdateReviewMock.callArgs, &mm_params)
	mmUpdateReview.UpdateReviewMock.mutex.Unlock()

	for _, e := range mmUpdateReview.UpdateReviewMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateReview.UpdateReviewMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReview.UpdateReviewMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReview.UpdateReviewMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReview.UpdateReviewMock.defaultExpectation.paramPtrs

		mm_got := ReviewRepositoryMockUpdateReviewParams{ctx, review}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReview.t.Errorf("ReviewRepositoryMock.UpdateReview got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReview.UpdateReviewMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.review != nil && !minimock.Equal(*mm_want_ptrs.review, mm_got.review) {
				mmUpdateReview.t.Errorf("ReviewRepositoryMock.UpdateReview got unexpected parameter review, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReview.UpdateReviewMock.defaultExpectation.expectationOrigins.originReview, *mm_want_ptrs.review, mm_got.review, minimock.Diff(*mm_want_ptrs.review, mm_got.review))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReview.t.Errorf("ReviewRepositoryMock.UpdateReview got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateReview.UpdateReviewMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReview.UpdateReviewMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReview.t.Fatal("No results are set for the ReviewRepositoryMock.UpdateReview")
		}
		return (*mm_results).err
	}
	if mmUpdateReview.funcUpdateReview != nil {
		return mmUpdateReview.funcUpdateReview(ctx, review)
	}
	mmUpdateReview.t.Fatalf("Unexpected call to ReviewRepositoryMock.UpdateReview. %v %v", ctx, review)
	return
}

// UpdateReviewAfterCounter returns a count of finished ReviewRepositoryMock.UpdateReview invocations
func (mmUpdateReview *ReviewRepositoryMock) UpdateReviewAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReview.afterUpdateReviewCounter)
}

// UpdateReviewBeforeCounter returns a count of ReviewRepositoryMock.UpdateReview invocations
func (mmUpdateReview *ReviewRepositoryMock) UpdateReviewBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReview.beforeUpdateReviewCounter)
}

// Calls returns a list of arguments used in each call to ReviewRepositoryMock.UpdateReview.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReview *mReviewRepositoryMockUpdateReview) Calls() []*ReviewRepositoryMockUpdateReviewParams {
	mmUpdateReview.mutex.RLock()

	argCopy := make([]*ReviewRepositoryMockUpdateReviewParams, len(mmUpdateReview.callArgs))
	copy(argCopy, mmUpdateReview.callArgs)

	mmUpdateReview.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReviewDone returns true if the count of the UpdateReview invocations corresponds
// the number of defined expectations
func (m *ReviewRepositoryMock) MinimockUpdateReviewDone() bool {
	if m.UpdateReviewMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReviewMock.invocationsDone()
}

// MinimockUpdateReviewInspect logs each unmet expectation
func (m *ReviewRepositoryMock) MinimockUpdateReviewInspect() {
	for _, e := range m.UpdateReviewMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ReviewRepositoryMock.UpdateReview at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateReviewCounter := mm_atomic.LoadUint64(&m.afterUpdateReviewCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReviewMock.defaultExpectation != nil && afterUpdateReviewCounter < 1 {
		if m.UpdateReviewMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ReviewRepositoryMock.UpdateReview at\n%s", m.UpdateReviewMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ReviewRepositoryMock.UpdateReview at\n%s with params: %#v", m.UpdateReviewMock.defaultExpectation.expectationOrigins.origin, *m.UpdateReviewMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReview != nil && afterUpdateReviewCounter < 1 {
		m.t.Errorf("Expected call to ReviewRepositoryMock.UpdateReview at\n%s", m.funcUpdateReviewOrigin)
	}

	if !m.UpdateReviewMock.invocationsDone() && afterUpdateReviewCounter > 0 {
		m.t.Errorf("Expected %d calls to ReviewRepositoryMock.UpdateReview at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReviewMock.expectedInvocations), m.UpdateReviewMock.expectedInvocationsOrigin, afterUpdateReviewCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ReviewRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateReviewInspect()

			m.MinimockGetReviewsInspect()

			m.MinimockUpdateReviewInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ReviewRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ReviewRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateReviewDone() &&
		m.MinimockGetReviewsDone() &&
		m.MinimockUpdateReviewDone()
}
